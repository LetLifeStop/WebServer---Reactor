第一，关于竞态条件的讨论

当前有如下情景，同一个类对象tmp，线程A打算调用析构函数将tmp销毁掉，线程B打算通过tmp来实现类的一些功能

```
class Poll{
  public:
    Poll(){}
    ~Poll(){}
    void f();
};
```

如果线程A正在销毁tmp，而这个时候线程B却正在通过tmp实现类的一些功能，这个程序就很有可能死掉。

如果通过互斥锁的形式的话

```
// thread A
Poll::~Poll(){
  MutexLockGuard lock(mutex_);
  // delete tmp;
}
// thread B
if(tmp){
  MutexlockGuard lock(mutex_);
  // achieve some function
}
```

如果线程A拿到了锁，并且准备进行销毁，而此时线程B通过了if检验，这个时候程序也会死掉，从这里可以看出，**互斥量也不能保护析构函数**，那条件变量可以吗？应该还是不行

应该采用什么方式使得线程A和线程B能正确运行，并且程序不会死掉？

书中提到了使用对象池，简单理解就是指创建对象但是不销毁对象，如果申请新的时候，如果之前存在过，就进行重复利用。

但是这样会产生比较多的副作用，怎么样使得所有的线程都知道对象是否还存活？只申请但是不进行对象的销毁，会造成资源的浪费

接下来引入了智能指针，主要介绍的是shared_ptr，weak_ptr，scoped_ptr。

shared_ptr是可以控制对象的生命周期的，只要一个对象所对应的shared_ptr数目不为0，这个对象就不会被销毁。当这个对象对应的shared_ptr数目为0的时候，这个对象就会自动销毁。（在使用智能指针的前提下，new和delete的个数可以不相同，甚至可以只有new，没有delete）

weak_ptr （ https://zh.cppreference.com/w/cpp/memory/weak_ptr ）是用来给shared_ptr 当小弟的，可以判断对象是否还存活，如果对象还存活，就可以提升为shared_ptr。还有一个作用就是可以防止shared_ptr造成的死锁问题。

scoped_ptr，在对象析构的时候自动释放内存，能保证方在离开作用域之后他所管理的对象能被自动释放。

一般c++可能出现的内存问题可以分为以下几类：

- 缓冲区溢出
- 指针悬挂或者野指针
- 内存被释放多次
- 申请的内存没有被释放
- 内存碎片

对于前四个问题，（第五个问题后面会讲）

- 第一个，缓冲区溢出，可以通过string，vector等来解决
- 第二，三个，通过shared_ptr指针可以很好的解决
- 第三个，可以通过scoped_ptr，只在对象析构的时候释放一次
- 第四个，可以通过scoped_ptr，当作用域结束，在对象进行析构的时候会进行一次释放

 那么只能指针是如何解决竞态条件的呢？

拿书上的一个例子进行解释：

```c++
class Observer{
  public:
    virtual ~Observer();
    virtual void update() = 0;
};

class Observable{
  public:
    void register_(weak_ptr<Observer> x);
    // void unregister(weak_ptr<Observer> x);
    void notifyObservers();
  private:
    mutable MutexLock mutex_;
    std::vector<weak_ptr<Observer> > observers_;
    typedef std::vector<weak_ptr<Observer> >::iterator Interator;
};

void Observerable::notifyObservers(){
  MutexLockGuard lock(mutex_);
  Iterator it = observers_.begin();
  while(it != observers_.end()){
    // weak_ptr 可以转换成shared_ptr，并且shared_ptr对应的引用计数 + 1，原来也存在，现在又加了一个，所以现在的引用计数值几乎总是大于等于2
    shared_ptr<Observer> obj(it->lock());
    if(obj){
    // 这一步是线程安全的，没有竞态条件的发生
    // 具体原因，因为在4G虚拟空间中，每个线程是有各自的栈空间，别的线程是无法访问当前线程的栈空间的，再加上shared_ptr相当于直接一根线绑定了这个对象，无论其他线程怎么搞，我只要这里一直绑着就可以了，别人也不可以解绑
      obj->update();
        ++it;
    }
    else 
      it = observers_.erase(it);   
  }
}
```



但是这样一定是好的吗？（怎么停不下来啊，啥都有点问题，这样下去才更有魅力吧）

  如果使用智能指针的话，并不是完全线程安全的

* observer析构函数怎么保证是一定能顺利实现？

* 怎么保证observer实现析构函数的时候observer还是存在的？（不受智能指针引用计数为0自动销毁的影响）
* 死锁，如果在update函数中，调用了register函数，如果register函数的调用需要锁的话，这样就造成了死锁。其次，如果mutex是可重入性的，vector的遍历的期间就会被修改
* 锁竞争，如果register，unregister， update都需要锁的话，update执行的时间是没有上限的，我们希望register和unregister函数的执行时间不会超过某个固定的上限
* shared_ptr指针允许多线程访问，如果其中一个线程正在执行析构函数，怎么保证其他线程不会执行析构函数？（**shared_ptr和mutex相结合**）



